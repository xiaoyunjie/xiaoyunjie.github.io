{"meta":{"title":"猪蹄胖的窝","subtitle":null,"description":"孩儿们,造起来","author":"Browser","url":"https://www.browsersytle.cn","root":"/blog/"},"pages":[{"title":"404 Not Found：该页无法显示","date":"2019-06-05T07:14:44.119Z","updated":"2019-06-05T07:14:44.119Z","comments":false,"path":"/404.html","permalink":"https://www.browsersytle.cn//404.html","excerpt":"","text":""},{"title":"关于","date":"2019-06-05T07:19:14.487Z","updated":"2019-06-05T07:19:14.484Z","comments":true,"path":"about/index.html","permalink":"https://www.browsersytle.cn/about/index.html","excerpt":"","text":"个人详细介绍运维开发一枚，平时较忙，放假就想懒懒的躺着不动，所以文章更新较慢。其实平时的积累都有写成文档，只是慵懒的躺着时间久了，发布都不想发布，哈哈"},{"title":"书单","date":"2019-06-04T06:55:20.407Z","updated":"2019-06-04T06:55:20.407Z","comments":false,"path":"books/index.html","permalink":"https://www.browsersytle.cn/books/index.html","excerpt":"","text":""},{"title":"分类","date":"2019-06-05T07:14:27.727Z","updated":"2019-06-05T07:14:27.727Z","comments":false,"path":"categories/index.html","permalink":"https://www.browsersytle.cn/categories/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2019-06-05T07:14:10.824Z","updated":"2019-06-05T07:14:10.824Z","comments":true,"path":"links/index.html","permalink":"https://www.browsersytle.cn/links/index.html","excerpt":"","text":""},{"title":"Repositories","date":"2019-06-04T06:55:20.407Z","updated":"2019-06-04T06:55:20.407Z","comments":false,"path":"repository/index.html","permalink":"https://www.browsersytle.cn/repository/index.html","excerpt":"","text":""},{"title":"标签","date":"2019-06-05T07:25:15.405Z","updated":"2019-06-05T07:25:15.405Z","comments":false,"path":"tags/index.html","permalink":"https://www.browsersytle.cn/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"SQL基础","slug":"SQL基础","date":"2019-07-22T14:32:03.000Z","updated":"2019-07-22T14:33:59.297Z","comments":true,"path":"2019/07/22/SQL基础.html","link":"","permalink":"https://www.browsersytle.cn/2019/07/22/SQL基础.html","excerpt":"","text":"1、SQL概述 基本概念数据Data: 描述事务的符号记录数据库Database: 存放数据的仓库，所有数据在计算机存储设备上按照一定格式进行保存数据库管理系统DBMS: 高效的获取和维护数据数据库系统DBS: 在计算机系统中引入数据库后的系统 SQL语言的组成数据操作类SQL语句功能SELECT从数据库表中检索数据行和列INSERT把新的数据记录添加到数据库中DELETE从数据库中删除数据记录UPDATE修改现有数据库中的数据数据定义类SQL语句功能CREATE TABLE创建一个数据表DROP TABLE删除一个表ALTER TABLE修改一个现存表的结构CREATE VIEW创建视图DROP VIEW删除视图CREATE INDEX创建索引DROP INDEX删除索引CREATE PROCEDURE创建存储过程DROP PROCEDURE删除存储过程CREATE TRIGGER创建一个触发器DROP TRIGGER删除触发器CREATE SCHEMA创建一个新模式DROP SCHEMA删除一个模式CREATE DOMAIN创建一个数据值域ALTER DOMAIN改变域定义DROP DOMAIN删除一个域数据控制类SQL语句功能GRANT授权用户访问权限DENY拒绝用户访问REVOKE删除用户访问权限事务控制类SQL语句功能COMMIT结束当前事务，并提交ROLLBACK回滚事务SET TRANSACTION定义当前事务数据访问特征程序化SQL语句功能DECLARE定义查询游标EXPLAN描述查询数据访问计划OPEN检索查询结果打开一个游标FETCH检索一条查询结果记录CLOSE关闭游标PREPARE为动态执行准备SQL语句EXECUTE动态执行SQL语句DESCRIBE描述准备好的查询 SQL语句结构1234567SELECT 字句[INTO 字句]FROM 字句[WHERE 字句][GROUP BY 字句][HAVING 字句][ORDER BY 字句] 2、简单查询 单列查询123select list from table_name;# list: 列名# table_name:表名SQL关键字不严格区分大小写 多列查询12select goods_id,goods_name,market_price from goods;# 多列用,隔开 查询所有列12select * from table_name;# “*” 表示所有的列，通配 别名别名增强阅读性12345678# 双引号创建别名select goods_name \"商品名称\" from goods;# 单引号创建别名select goods_name \"商品名称\" from goods;# 不使用引号创建别名select goods_name 商品名称 from goods;# 使用AS关键字创建别名select goods_name AS \"商品名称\" from goods; 删除重复数据DISTINCT关键字可以从SELECT语句的结果中删除重复的行，并且DISTINCT关键字放在第一个字段名前面。123select [distinct|all] select_list from table_name;# 例子select distinct address,mobile,consignee from orderform; 限制查询12345678910# 查询前n行数据, 0&lt;n&lt;4294967295select top n from table;# MYSQL查询前5行select goods_name,market_price from shop.goods limit 5；# MYSQL查询第三到第五条数据select goods_name,market_price from shop.goods limit 2,5# MYSQL查询信息从第4条开始2条数据信息select goods_name,market_price from shop.goods limit 2 offset 3;# Oracle查询前5条数据select goods_name from goods where rownum &lt;= 5; 3、计算列查询对某两个列进行相加相减计算，通过计算得到新的一列数据 连接列值12# 合并列，定义名别select name + cat_name AS '品牌信息' from brand; 计算列123456789# 减法运算select goods_id AS '商品ID',goods_name AS '商品名称',(shop_price - cost_price) AS '销售利润' from goods;# 乘法运算select goods_id AS '商品ID',goods_name AS '商品名称',(shop_price * sales_sum AS '销售额' from goods; # 综合引用select goods_id AS '商品ID',goods_name AS '商品名称',(sales_sum*shop_price - sales_sum*cost_price)/sales_sum AS '销售利润' from goodswhere sales_sum &lt;&gt; 0;# &lt;&gt; 不等于 查询使用表达式12345678# 数值表达式select goods_id AS '商品ID',goods_name AS '商品名称',cost_price + 50 AS 进价加50from goods;# 字符表达式select goods_id AS '商品ID',goods_name AS '商品名称',convert(char(2),sales_sum)+'个' AS 销售数量，conver(char(8),shop_price)+'元' AS '商场价格' from goods; 4、条件查询 Where字句123select 字句from 表名where 条件表达式 比较运算符限制查询12345678910111213141516171819202122232425# '='查询数据select * from goods where goods_id = 106;# '&gt;'查询数据select * from goods_id,goods_name,click_count from goodswhere click_count &gt; 50;# '&lt;'查询数据select goods_id,goods_name,store_count from goodswhere store_count &lt; 1000;# '&gt;='查询数据select goods_id,goods_name,sales_sum from goodswhere sales_sum &gt;= 5;# '&lt;='查询数据select goods_id,goods_name,click_count from goodswhere click_count &lt;= 20;# '!&gt;'查询数据,不大于或小于等于select goods_id,goods_name,shop_price from goodswhere shop_price !&gt; 2000;# '!&lt;'查询数据，不小于，大于等于select goods_id,goods_name,shop_price from goodswhere shop_price !&lt; 2000;# !=和&lt;&gt;查询数据select goods_id,goods_name,is_newfrom goods where is_new != 0;select goods_id,goods_name,is_newfrom goods where is_new &lt;&gt; 0; 5、范围查询between...and...1234567891011# 查询两个值之间的数据select goods_id AS '商品ID',goods_name AS '商品名称',market_price AS 市场价from goodswhere market_price between 1000 and 3000;# 在between中使用日期函数select ISBN,BookName,INTime 数据录入时间 from bookinfo_zerobasiswhere between DATEADD(DAY,-1,GETDATE()) and GETDATE();# 查询不在between之间的数据select goods_id,goods_name,market_pricefrom goodswhere market_price not between 2000 and 3000; 日期时间查询1234# date_type: 数据类型# expression: DATETIME类型的数据# style: 指定转换形式[0-21]convert(date_type[(length)],expression,style) 计算两个日期的间隔天数1datediff(datepart,startdate,enddate) 指定日期查询数据123456789# day()函数select day(0) AS MY_DAY1,day('01/02/2019') AS MY_DAY2;# month()函数select 'month number' = month('03.01.2019');# yeah()函数select yeah(-1) AS MY_YEAR1,yeah(3) AS MY_YEAR2,yeah('01/02/2019') AS MY_YEAR3; 6、逻辑运算符过滤数据 and 运算符123select goods_name,click_count,store_count,shop_pricefrom goodswhere click_count &gt; 20 and store_count = 1000 and shop_price &gt; 2000; or 运算符123select ISBN,BookName,Writer,Pricefrom bookinfo_zerobasiswhere BookName='sql' or BookName='java'; not 运算符123select good_id,goods_namefrom goodswhere not store_count = 1000;逻辑运算符的优先级，NOT &gt; AND &gt; OR 7、IN操作符过滤数据 使用IN查询数据使用IN操作符可以判断某个字段的值是否在指定的集合中，如果字段的值在集合中，则满足查询条件，该记录将被查询出来，如果不在集合中，则不满足查询条件，使用IN操作符查询数据的基本语法：123456select column_namefrom table_namewhere column_name in (value1,value2....);## column_name : 列名## table_name : 表名## value : 值列表123select cat_id,goods_namefrom goodswhere cat_id in (191,123,131); 在IN中使用算数表达式123select goods_name,shop_pricefrom goodswhere shop_price in (3799-100,3799,3799+100); 在IN中使用列进行查询值列表不仅可以使用数值类型和字符类型，还可以是用列名作为值列表123select goods_name,market_price,shop_pricefrom goodswhere 3899 in (market_price,shop_price); 使用not in 查询后两行数据123select order_id,order_sn,total_ammountfrom orderformwhere order_id not in (select TOP 8 order_id form orderform); 8、格式化结果集格式化结果集通过使用一些函数，将结果集中的某列数据进行格式化，以方便用户查看，例如将日期格式化 格式化日期123456## sqlserverconvert (data_type[(length)],expression [, style])## data_type : 规定目标数据类型## length : nchar、nvarchar、char、varchar、binary、varbinary数据类型规定长度## expression : 需要转换的值## style : 可选参数，输出格式12select convert(varchar,getdate(),108) AS nowtime;## 结果: 10:16:15 格式化小数位数12## sqlserverselect cast(236.11 AS int); 去掉空格ltrim()函数去除字符串左边的多余的空格1select ltrim(' MR') AS '去掉左空格',ltrim(' Book') AS '去掉左空格'; 9、模糊查询 like谓词通配符说明%由零个或多个字符组成的任意字符串_任意单个字符[ ]用于指定范围，例如[A~F][^ ]表示like 谓词通过指定通配符可以指定任何的模糊查询条件某列包含mr字符，mr出现在任意位置： where 列名 like '%mr%'某列名包含mr字符，mr出现在开头位置： where 列名 like 'mr%'某列名包含mr字符，mr出现在结尾位置：where 列名 like '%mr'某列中前两字符为mr，后一个字符任意： where 列名 like 'mr_'某列中前一个字符任意，后两字符mr： where 列名 like '_mr'查询某列不是以m或r开头的数据： where 列名 like '[^mr]%'123select goods_id,goods_name,shop_pricefrom goodswhere goods_name like '%华为%'123select address_id,ltrim(consignee) AS consignee,addressfrom user_addresswhere ltrim(consignee) like '___' escape 定义转移字符1234select user_id,email,convert(varchar(10),birthday,120) AS birthdayfrom userswhere mail like '%/_%' escape '/';## / 被定义为转义字符，后面的%被解释为普通字符 10、行数据过滤mysql随机查询一行数据，使用rand()函数123select goods_id,cat_idfrom goodsorder by rand() limit 1; 查询指定范围内的所有行数据1234# 在bookinfo_zerobasis 表中查询出3到6行的ISBN，bookname和writerselect 编号,ISBN,BookName Writer from (select row_number() over(order by ISBN) 编号,ISBN,BookName,Writerfrom bookinfo_zerobasis) a where a.编号 between 3 and 6; 查询空值null123select user_id,email,nicknamefrom userswhere nickname is null; 查询非空值123select user_id,email,nicknamefrom userswhere nickname is not null; 对空值进行处理ISNULL()函数可以将空值转换为有效的值，NULLIF()函数可以根据指定的条件来生成空值。mysql中ISNULL()函数只有一个参数，它的作用是判断参数是否为null，如果为null返回1，否则返回0。123# 在查询中，将空值置为0select BookName,Writer,ISNULL(newbook,0) AS newbookfrom bookinfo_zerobasis;123# 将andy转换成nullselect user_id,email,nullif(nickname,'Andy') AS nicknamefrom users; 11、数据排序ASC升序，DESC降序123select goods_id,goods_name,sales_sumfrom goodsorder by sales_sum desc;多列排序：主排列没有重复值，则不进行次排列，如果主排列出现重复值，需要进行次排列。123select top 3 goods_id,goods_name,shop_pricefrom goodsorder by shop_price desc,goods_name desc; 12、数据统计分析sum(),avg(),min(),max(),count([distinct]*)123456select sum(成绩) from grade;select avg(年龄) from student;select count(*) from student;select min(日期) from student;select max(成绩) from grade;select count([distinct] cat_id) AS 商品种类 from goods;多个聚合函数在SQLServer中不能嵌套sum(max(cols))子查询不能作为一个聚合函数的表达式avg(select * from tablename)**聚合函数执行步骤：**执行一条select 语句来显示一个或多个聚合函数的步骤首先产生一个中间表如果在select语句中存在一个where字句，就对中间表中每一行根据其搜索条件进行求值清除那些求值结果为false和null的行，保留求值结果为true的行使用中间表的值来计算每个聚合函数的值将每个聚合函数统计的值作为结果表中的列值显示 13、分组统计123select cat_id AS 商品种类ID,count(*) AS 数量from goodsgroup by cat_id;123456select cat_id 商品种类id,shop_price 商品售价,count(cat_id) 数量from goodswhere(shore_count &lt; 1000)group by cat_id,shop_pricehaving (shop_price &gt; (select avg(shop_price) from goods))order by shop_price desc; 14、简单子查询语法格式：123where [expression] [not] IN (子查询)where [expression] 比较运算符 [ANY | ALL] (子查询)where [not] exists (子查询) 列表子查询12345select tb_book_author,tb_author_department, (select max(book_price) from tb_book where tb_book_author.tb_book_author=tb_book.tb_book_author)from tb_book_author; 比较子查询1234567select cat_id,goods_namefrom goodswhere cat_id &gt; ( select cat_id from brand where name='hello');子查询不能返回多个值子查询中不能包含order by 字句 子查询中使用聚合函数12select min(((number1+number2)-abs(number1-numbers))/2) AS '最小数'from (select * from tb_min where (number1&gt;0 and number2&gt;0)) a;123select ename,sal,jobfrom empwhere sal &gt; (select avg(sal) from emp); 15、多行子查询使用not in 子查询实现差集运算1234select * from tb_bookwhere book_sort not in ( select tb_author_department from tb_book_author);exists 子查询的功能是判断子查询的返回结果中是否有数据行，如果返回空集则判断为不存在使用not exists ，如果子查询结果为空，外层的where 字句返回true 16、多表连接 内连接内连接就是使用比较运算符进行表与表之间列数据的比较操作，并列出这些表中与连接条件相匹配的数据行等值连接：在连接条件中使用等于运算符比较被连接的列123select goods_id,goods_name,namefrom goods,goods_typewhere goods.goods_type=goods_type.id不等值连接：在连接条件中使用除了等于运算符以外的其他运算符比较被连接的列123select a.goods_id,a.goods_namefrom goods a inner join (select * from goods_type where name='电脑') bon a.goods_type &lt;&gt; b.id;自然连接：等值连接的特殊情况，把目标中重复的属性列去掉123select a.user_id,b_address,convert(varchar(10),last_login,120) as last_loginfrom users a,user_address b where a.users_id=b.users_id; 外连接外连接查询的结果是内连接查询的扩展，使用外连接可以方便的连接结果中包含某个表中的其他记录。左外连接：表示在结果中包括左表中不满足条件的数据123select goods_id,goods_name,namefrom goods left join goods_typeon goods.goods_type=goods_type.id order by goods_id DESC;右外连接：表示在结果中包括右表中不满足条件的数据123select goods_id,goods_name,namefrom goods right join goods_typeon goods.goods_type=goods_type.id;全外连接：表示在结果中包括左表和右表不满足条件的数据123select goods_id,goods_name,namefrom goods full join goods_typeon goods.goods_type=goods_type.id order by goods_id 17、插入数据 插入单行数据1insert [into] table_or_view [(column_list)] values (values_list)table_or_view：表名或视图的名称column_list：列表名values_list：作为一行或多行插入已命名的表或视图中 插入多行数据1insert [into] table_name [(column_list)] values (data11,data12,...),(data21,data22,...),... 表数据复制12345-- sqlserverselect [select_list] into new_tablefrom table_namewhere search_condition 18、更新和删除数据 updateupdate 语句用来修改表中的数据，一种是更新表中指定的行，另一种是更新表中的所有行123update table_nameset column1 = value1,column2 = value2,....where search_condition delete123delete [from]&#123;table_name | view_name&#125;[where search_condition]与delete相比，truncate table语句不但删除了数据，而且所删除的数据在事务处理日志中还会做相应的记录，而且效率比delete高。 19、视图 创建视图12345678create view view_name [(column_name)] AS select_statement[with check option]--create table GoodsPriceASselect goods_id,goods_name,shop_pricefrom goods; 删除视图123Drop view view_name--drop view GoodsPirce通过视图简化复杂查询使用视图过滤不想要的数据通过视图显示函数的结果通过视图添加数据123insert into view_name[(view column name...[,view column name])]values (view column value...[,view cloumn value])通过视图更新数据123update view_nameset column1=expression1[,column2=expression][,...][where condition]通过视图删除数据1delete view_name where search_condition 20、存储过程存储过程即预先编译好的Transact-SQL，可以接受和输出参数。 创建存储过程1234--examplecreate procedure CRE_PRO ASselect * from brand where cat_name = '食品' 执行存储过程12--exampleexec CRE_PRO 修改存储过程12345678--examplealter procedure CRE_PROAS select name,cat_name,cat_idfrom brandwhere cat_name = '运动'--exec CRE_PRO 删除存储过程12--exampledrop procedure CRE_PRO 21、游标游标提供了一种从表中检索数据并进行操作的灵活手段申明游标123declare cursor_name CURSOR for select_statement--declare cur_goods CURSOR for select * from goods打开游标1open cursor_name读取数据123456-- sqlserverfetch [[next | prior|first|last] from]cursor_name[into @variable_name [,....n]]关闭游标1close cursor_name释放游标1deallocate &#123;&#123;[global] cursor_name&#125; | @cursor_variable_name &#125;123456789101112--exampledeclare add_cur CURSOR for select * from user_addressopen add_curfetch next from add_cur while @@fetch_status = 0begin fetch next from add_curendclose add_curdeallocate add_cur 22、事务处理事务及逻辑工作单元，包括：原子性：事务对数据库操作要么全部执行，要么全部取消，失败则回滚。一致性：事务完成是，必须所有数据都保持一致状态。隔离性：事务与事务之间的修改必须隔离。持久性：事务提交后，对数据库所做的修改要永久保存下来。","categories":[{"name":"SQL","slug":"SQL","permalink":"https://www.browsersytle.cn/categories/SQL/"}],"tags":[{"name":"basic","slug":"basic","permalink":"https://www.browsersytle.cn/tags/basic/"}]},{"title":"Tcpdump","slug":"Tcpdump","date":"2019-07-16T14:55:19.000Z","updated":"2019-07-16T14:58:38.590Z","comments":true,"path":"2019/07/16/Tcpdump.html","link":"","permalink":"https://www.browsersytle.cn/2019/07/16/Tcpdump.html","excerpt":"","text":"tcpdump=dump the traffic on a network是 一款对网络数据截获并分析的工具，libpcap是一个unix/linux系统下的网络数据捕获函数包。 一、语法和用法 关键字主要包括host，net，port 例如 host 10.1.1.1指明 192.168.1.1是一台主机，net 202.0.0.0 指明 202.0.0.0是一个网络地址，port 23 指明端口号是23。如果没有指定类型，缺省的类型是host。 传输方向主要包括src , dst ,dst or src, dst and src这些关键字指明了传输的方向。举例说明，src 10.1.1.1 ,指明IP包中源地址是10.1.1.1, dst net 202.0.0.0指明目的网络地址是202.0.0.0 。如果没有指明方向关键字，则缺省是src or dst关键字。 协议主要包括fddi,ip,arp,rarp,tcp,udp等类型。几个关键字就是指明了监听的包的协议内容。如果没有指定任何协议，则tcpdump将会监听所有协议的信息包。 逻辑运算非运算是：not ! ；与运算是and &amp;&amp;;或运算 是or ||；1234567891011121314tcpdump [-nn] [-i 界面] [-w 存储名] [-c 次数] [-e] [-qX] [-r 档案]# -AbdDefhHIJKlLnNOpqRStuUvxX 参数列表#-c&lt;数据包数目&gt;：收到指定的数据包数目后，就停止进行倾倒操作；#-C 文件大小：file_size#-e：在每列倾倒资料上显示连接层级的文件头；#-i&lt;网络界面&gt;：使用指定的网络截面送出数据包；#-nn：直接以IP或portnumber显示，而非主机名；#-q ：快速输出，仅列出少数的传输协议信息，内容精简；#-r&lt;数据包文件&gt;：从指定的文件读取数据包数据；#-s&lt;数据包大小&gt;：设置每个数据包的大小；#-tt： 在每列倾倒资料上显示未经格式化的时间戳记； #-v：详细显示指令执行过程；#-x：用十六进制字码列出数据包资料；#-w&lt;数据包文件&gt;：把数据包数据写入指定的文件。直接启动tcpdump将监听第一个网络接口上所有流过的数据包1[root@linux ~]$ tcpdump监听指定网络接口1[root@linux ~]$ tcpdump -i eth0截获所有210.27.48.1 的主机收到的和发出的所有的数据包1[root@linux ~]$ tcpdump host 210.27.48.1截获主机210.27.48.1 和主机210.27.48.2 或210.27.48.3的通信1[root@linux ~]$ tcpdump host 210.27.48.1 and / (210.27.48.2 or 210.27.48.3/)截取主机192.168.1.1除了和主机192.168.1.2之外所有主机通信的ip包1[root@linux ~]$ tcpdump host 192.168.1.1 ! 192.168.1.2获取主机10.1.1.1接收或发出的telnet包1[root@linux ~]$ tcpdump host 10.1.1.1 and tcp port 23监听主机10.1.1.1 发送的所有数据包1[root@linux ~]$ tcpdump src host 10.1.1.1监听所有发送到172.16.1.1的数据包1[root@linux ~]$ tcpdump dst host 172.16.1.1截取主机10.1.1.1发送的一万个包，且抓取的数据包包头长度为80，最后保存到指定路径下1[root@linux ~]$ tcpdump -i eth0 src host 10.1.1.1 -c 10000 -s 80 -w /tmp/test.pcap 二、实用案例 案例一以 IP与port number截取 eth0这个网卡上的封包，持续3 秒123456789[root@linux ~]$ tcpdump -i eth0 -nntcpdump: verbose output suppressed, use -v or -vv for full protocol decodelistening on eth0, link-type EN10MB (Ethernet), capture size 96 bytes01:33:40.41 IP 192.168.1.100.22 &gt; 192.168.1.11.1190: P 116:232(116) ack 1 win 964801:33:40.41 IP 192.168.1.100.22 &gt; 192.168.1.11.1190: P 232:364(132) ack 1 win 9648#按下 [ctrl+c]结束监听6680 packets captured #截取下來的封包數量14250 packets received by filter #由过滤所得的总封包数量7512 packets dropped by kernel #被核心所丢弃的封包 案例二监听端口eth0并且显示出端口21的连线包123456789[root@linux ~]$ tcpdump -i eth0 -nn port 21tcpdump: verbose output suppressed, use -v or -vv for full protocol decodelistening on eth0, link-type EN10MB (Ethernet), capture size 96 bytes01:54:37.96 IP 192.168.1.11.1240 &gt; 192.168.1.100.21: . ack 1 win 6553501:54:37.96 IP 192.168.1.100.21 &gt; 192.168.1.11.1240: P 1:21(20) ack 1 win 584001:54:38.12 IP 192.168.1.11.1240 &gt; 192.168.1.100.21: . ack 21 win 6551501:54:42.79 IP 192.168.1.11.1240 &gt; 192.168.1.100.21: P 1:17(16) ack 21 win 6551501:54:42.79 IP 192.168.1.100.21 &gt; 192.168.1.11.1240: . ack 17 win 584001:54:42.79 IP 192.168.1.100.21 &gt; 192.168.1.11.1240: P 21:55(34) ack 17 win 5840 案例三监听还回口lo的21号端口数据包，并且直接以16进制列出数据包资料123456789101112131415161718[root@linux ~]$ tcpdump -i lo -nn -X 'port 21' 0x0000: 4500 0048 2a28 4000 4006 1286 7f00 0001 E..H*(@.@....... 0x0010: 7f00 0001 0015 80ab 8355 2149 835c d825 .........U!I./.% 0x0020: 8018 2000 fe3c 0000 0101 080a 0e2e 0b67 .....&lt;.........g 0x0030: 0e2e 0b61 3232 3020 2876 7346 5450 6420 ...a220.(vsFTPd. 0x0040: 322e 302e 3129 0d0a 2.0.1).. 0x0000: 4510 0041 d34b 4000 4006 6959 7f00 0001 E..A.K@.@.iY.... 0x0010: 7f00 0001 80ab 0015 835c d825 8355 215d ........./.%.U!] 0x0020: 8018 2000 fe35 0000 0101 080a 0e2e 1b37 .....5.........7 0x0030: 0e2e 0b67 5553 4552 2064 6d74 7361 690d ...gUSER..admin. 0x0040: 0a . 0x0000: 4510 004a d34f 4000 4006 694c 7f00 0001 E..J.O@.@.iL.... 0x0010: 7f00 0001 80ab 0015 835c d832 8355 217f ........./.2.U!. 0x0020: 8018 2000 fe3e 0000 0101 080a 0e2e 3227 .....&gt;........2' 0x0030: 0e2e 1b38 5041 5353 206d 7970 6173 7377 ...8PASS.p@ssw0r 0x0040: 6f72 6469 7379 6f75 0d0a d..上述的显示的是16进制数据，通过grep等过滤详细关键字后，可以发现特殊字体中显示了软件vsFTP，并且由于是明文，所以能看到账号与密码。 报警信息为了让网络接口可以被tcpdump监听，所以执行 tcpdump 时，网络接口会启动 『混杂模式 (promiscuous)』，所以你能在 /var/log/messages 里面看到很多的告警信息， 通知你的网络接口被设定为混杂模式这种情况是正常的，只是在这种模式下会监听到更多的数据包。 其他应用可以参考man tcpdump。","categories":[{"name":"network","slug":"network","permalink":"https://www.browsersytle.cn/categories/network/"}],"tags":[{"name":"tcpdump","slug":"tcpdump","permalink":"https://www.browsersytle.cn/tags/tcpdump/"}]},{"title":"理解TCP和UDP","slug":"理解TCP和UDP","date":"2019-07-16T14:41:22.000Z","updated":"2019-07-16T14:52:39.545Z","comments":true,"path":"2019/07/16/理解TCP和UDP.html","link":"","permalink":"https://www.browsersytle.cn/2019/07/16/理解TCP和UDP.html","excerpt":"","text":"一、TCP端口 二、TCP报文结构 三、TCP连接的建立和释放TCP的整个交互过程可总结为：先建立连接、然后传输数据、最后释放连接。其实网络上的传输是没有连接的，TCP所谓的连接，只不过是通信双方维护一个连接状态，看上去像是有连接 三次握手，连接建立过程TCP连接的建立采用客户-服务器方式，主动发起连接建立的一方叫客户端client，被动等待建立连接的一方叫服务端Server。最初，两端都处于CLOSED状态，然后服务器打开了TCP服务，进入LISTEN状态，监听特定端口，等待客户端的请求第一次握手：客户端主动打开连接，发送TCP报文，进行握手，然后进入SYN_SEND状态，等待服务器发回确认报文。首部同步位SYN置为1，同时初始化一个序列号SequenceNumber=X，TCP规定，SYN报文段不能携带数据，但是会消耗一个序号第二次握手：服务器收到了SYN报文，如果同意建立连接，则向客户端发送一个确认报文，然后服务器进入SYN_RCVD状态，首部SYN和ACK都置为1，确认号Acknowledge Number=X+1,同时为自己初始化一个需要SequenceNumber=Y 次报文同意不带数据第三次握手：客户端收到服务器发送的确认报文，还要向服务器给出确认，然后进入ESTABLISHED状态，这时首部的SYN不再置为1，而ACK置为1，确认好Acknowledge Number=Y+1，序号SequenceNumber=X+1，这次会携带真正的需要传输的数据，当服务器收到该数据报文时，就会同样进入ESTABLISHED状态，此时TCP建立连接对于建立连接的三次握手，主要目的是初始化Sequence Number，并且通信的双方都需要告知对方自己的初始化序号，此过程也叫SYN阶段.这个序号是作为接下来数据通信的序号，用来保证应用层接受到的数据不会因为网络上的传输问题二乱序，TCP需要用序号进行数据拼接 四次挥手，释放链接TCP的连接是全双工(可以同时发送和接受)的连接，因此在关闭连接时，必须关闭传送和接收两个方向的连接客户端给服务器发送一个携带FIN的TCP结束报文，然后服务器返回给客户端一个确认报文，同时发送一个结束报文，当客户端恢复一个确认报文后，连接结束结束之前都处于ESTABLISHED状态，模拟客户端先主动断开连接第一次挥手：客户端向服务器端发送结束报文，然后进入FIN_WAIT_1状态，此报文FIN置为1，Sequence Number=M第二次挥手：服务端接收到客户端的结束报文，发送确认报文，进入CLOSE_WAIT状态，此报文段ACK置为1，Sequence Number=M+1，客户端收到该报文，进入`FIN_WAIT_2 状态。第三次挥手：服务端向客户端发送结束报文，然后进入LAST_ACK状态，此报文FIN置为1，Sequence Number=N第四次挥手：客户端收到服务端的结束报文，然后发送确认报文，进入TIME_WAIT状态，经过2MSL时间之后，自动进入CLOSED状态，报文ACK置为1，Sequence Number=N+1，服务器收到报文后，进入CLOSED状态Client1CLOSED -&gt; SYN_SENT -&gt; ESTABLISHED -&gt; FIN_WAIT_1 -&gt; FIN_WAIT_2 -&gt; TIME_WAIT -&gt; CLOSEDServer1CLOSED -&gt; LISTEN -&gt; SYN_RECEIVED -&gt; ESTABLISHED -&gt; CLOSE_WAIT -&gt; LAST_ACK -&gt; CLOSED MSLMaximum Segment Lifetime（数据包的最大生命周期），是一个数据包能在互联网上生存的最长时间，若超过这个时间则该数据包将会消失在网络中。操作系统通常会将2MSL设为4分钟，最低不少于30秒，因而``TIME_WAIT状态一般维持在30秒至4分钟。这个是TCP/IP设计者设计的，也就是无法解决的。 TIME_WAITTIME_WAIT状态的存在主要有两个原因：可靠地实现TCP全双工连接的终止关闭TCP时，最后的ACK包是由主动关闭方发出的，如果ACK包丢失，被动关闭方将重发FIN包，因此主动方必须维护状态信息，以接收它重发这个ACK包。如果不维持这个状态信息，那么主动方将回到CLOSED状态，而被动方重发的FIN包响应RST包，产生一个错误，为避免四次握手协议中包丢失的情况，主动关闭方必须维持TIME_WAIT状态。确保迷路数据包重新出现而影响新连接TCP数据包可能由于路由器异常而迷路，在迷路期间，数据包发送方可能因超时而重发这个包，迷路的数据包在路由器恢复后也会被送到目的地，这个迷路的数据包就称为Lost Duplicate。在关闭一个TCP连接后，如果马上使用相同的IP地址和端口建立新的TCP连接，那可能出现迷路重复数据包在前一个连接关闭后再次出现，影响新建立的连接。为了避免这一情况，TCP协议不允许使用处于TIME_WAIT状态的连接的IP和端口启动一个新连接，只有经过2MSL的时间，确保上一次连接中所有的迷路重复数据包都已消失在网络中，才能安全地建立新连接。对于Client而言，每个连接都需要占用一个端口，而系统允许的可用端口数不足65000个,大量建立连接和主动断开，会耗尽端口对Server而言（特别是处理高并发短连接的Server），Server对每个端口上的连接数受到文件描述符的最大打开数的限制。所以，如果Server主动关闭连接，也会出现端口耗尽的情况 CLOSING不管如何CLOSING状态的TCP连接，即便没有收到自己发送FIN之后的ACK，也不会永久保持下去，保持多久取决于自己发送FIN时刻的RTT，然后RTT计算出的RTO按照最大的退避次数来退避，直到最终执行了固定次数的退避后，算出来的那个比较大的超时时间到期，然后TCP socket就销毁了。RTO（Retransmission TimeOut）即重传超时时间RTT（Round Trip Time）即往返时间，由三部分组成：链路的传播时间（propagation delay）、末端系统的处理时间、路由器缓存中的排队和处理时间（queuing delay）。其中，前两个部分的值对于一个TCP连接相对固定，路由器缓存中的排队和处理时间会随着整个网络拥塞程度的变化而变化。所以RTT的变化在一定程度上反应了网络的拥塞程度 四、TCP状态流转CLOSED:初始状态LISTEN:socket处于监听状态，可以接受连接SYN_SENT:客户端发送SYN报文，然后进入SYN_SENT状态，等待服务端确认SYN_RCVD:服务端接受到SYN报文ESTABLISHED:连接已建立FIN_WAIT_1:一方请求终止，等待对方FIN报文FIN_WAIT_2:对方回应了ACK报文之后进入此状态TIME_WAIT:接收到对方FIN报文，并自身响应ACK后，进入此状态CLOSING:罕见状态，在接收到对端ACK之前先接收到了FIN包，直接从FIN_WAIT_1进入CLOSING状态LAST_ACK:被动关闭的一方发送FIN后，等待ACK所处的状态CLOSED:等待超时进入CLOSED","categories":[{"name":"network","slug":"network","permalink":"https://www.browsersytle.cn/categories/network/"}],"tags":[{"name":"tcp/udp","slug":"tcp-udp","permalink":"https://www.browsersytle.cn/tags/tcp-udp/"}]},{"title":"Moloch网络回溯分析系统","slug":"Moloch网络回溯分析系统","date":"2019-07-16T14:26:49.000Z","updated":"2019-07-16T15:06:00.406Z","comments":true,"path":"2019/07/16/Moloch网络回溯分析系统.html","link":"","permalink":"https://www.browsersytle.cn/2019/07/16/Moloch网络回溯分析系统.html","excerpt":"","text":"Moloch 是一个由AOL开源的，能够大规模的捕获IPv4数据包(PCAP)、索引和数据库系统，由以下三个部分组成：capture ：绑定interface运行的单线程C语言应用viewer ：运行在capture主机上的node.js web应用elasticsearch : moloch的数据检索驱动Moloch git地址 git主页上README有较为详细的安装说明，以下是参照官方说明，我的安装记录，本章只为了快速搭建Moloch，都是使用RPM包安装。 一、系统要求和环境搭建存储数据包对机器的性能要求moloch提供了评估页面 Moloch Estimators本次安装，找了一台陈旧的机器，4G 1333内存，i3CPU，150 interl SSD，一块500GB HDD，这个配置相对简陋，并且我把所有组件都安装在了一台机器上面，如果有条件的话，请把Capture Machines和Elasticsearch Machines组件分开来安装，由于elasticsearch相当吃内存，2G内存的机器基本带不起来。Linux 系统(官方支持Centos、ubuntu、OS x)JDK (elasticsearch依赖，推荐8u65)python(nodejs 运行依赖，一般系统都自带v2.7满足需求)nodejs(当前的moloch版本支持node)Moloch is no longer supported on 32 bit machines内核4.X有助于抓包性能提升 二、安装elasticsearchES可以选择在moloch安装时安装，也可以单独安装，我这边选择单独安装，从elasticsearch官网下载rpm包，下载地址,最新的elasticsearch版本是v6.2.0，由于moloch支持较低版本，下载ealsticsearch-5.6.6版本的RPM包下载JDK12345678yum install -y wget curl perl-JSON perl-libwww-perl libyaml-devel ##依赖组件wget http://iso.epoint.com.cn/JDK/jdk-8u65-linux-x64.rpm ##下载jdkwget https://artifacts.elastic.co/downloads/elasticsearch/elasticsearch-5.6.6.rpm ##下载elasticsearchrpm -ivh jdk-8u65-linux-x64.rpm ##安装jdkrpm -ivh elasticsearch-5.6.6.rpm ##安装elasticsearchsystemctl daemon-reload ##重载修改过的配置文件systemctl enable elasticsearch.service ##开机启动elasticsearchsystemctl start elasticsearch.service ##启动elasticsearch 三、安装Moloch先去官网下载安装包Downloads，我下载的是Nightly版本，获取最新特性12wget https://files.molo.ch/builds/centos-7/moloch-nightly.x86_64.rpm ##下载molochrpm -ivh moloch-nightly.x86_64.rpm ##安装moloch 四、配置Moloch1234567891011121314/data/moloch/bin/Configure ##moloch基本配置Found interfaces: lo;ens160Semicolon ';' seperated list of interfaces to monitor [eth1] ens160 ##选择监听网卡，多个网卡用;隔开Install Elasticsearch server locally for demo, must have at least 3G of memory, NOT recommended for production use (yes or no) [no] no ##本机寻找elasticsearchElasticsearch server URL [http://localhost:9200] http://localhost:9200 ##本机的elasticsearch的URLPassword to encrypt S2S and other things [no-default] moloch ##配置密码Moloch - Creating configuration filesNot overwriting /data/moloch-nightly/etc/config.ini, delete and run again if update required (usually not), or edit by handInstalling systemd start files, use systemctlMoloch - Downloading GEO files2018-02-07 19:29:06 URL:http://www.maxmind.com/download/geoip/database/asnum/GeoIPASNum.dat.gz [2513493/2513493] -&gt; \"GeoIPASNum.dat.gz\" [1]2018-02-07 19:29:16 URL:http://download.maxmind.com/download/geoip/database/asnum/GeoIPASNumv6.dat.gz [2896577/2896577] -&gt; \"GeoIPASNumv6.dat.gz\" [1]2018-02-07 19:29:22 URL:http://www.maxmind.com/download/geoip/database/GeoLiteCountry/GeoIP.dat.gz [700469/700469] -&gt; \"GeoIP.dat.gz\" [1]2018-02-07 19:29:28 URL:http://geolite.maxmind.com/download/geoip/database/GeoIPv6.dat.gz [1110013/1110013] -&gt; \"GeoIPv6.dat.gz\" [1] 初始化、升级 Elasticsearch Moloch配置12/data/moloch-nightly/db/db.pl http://localhost:9200 init ##第一次安装初始化、或者想删除所有数据/data/moloch-nightly/db/db.pl http://localhost:9200 upgrade ##升级moloch 数据包 添加admin账户1/data/moloch-nightly/bin/moloch_add_user.sh admin \"Admin User\" moloch --admin ##新增admin账户，密码是moloch 开启所有服务1234systemctl enable molochcapture.service ##开机启动Capturesystemctl start molochcapture.service ##启动Capturesystemctl enable molochviewer.service ##开机启动Viewersystemctl start molochviewer.service ##启动Viewer 日志查看12tail -f /data/moloch-nightly/log/capture.logtail -f /data/moloch-nightly/log/viewer.log 数据清理ES的数据增长根据流量大小决定，如果不定期清理ES数据，总有一天空间会写满，所以要定期清理ES数据12345678cd /data/moloch-nightly/dbvim daily.sh#ES服务端口ESHOSTPORT=127.0.0.1:9200#保留ES日志七天RETAINNUMDAYS=7crontab -e 0 1 * * * sh /data/moloch-nightly/db/daily.sh &gt;&gt; /var/log/moloch/daily.log 2&gt;&amp;1 五、登入Moloch系统访问http://molochhost:8005user : adminpassword : moloch 六、FAQCapture服务抓取的数据包文件存储在/data/moloch-nightly/raw/ 目录下，如果流量大的化可以mount大一点的硬盘Elasticsearch由于是通过rpm包默认安装，数据文件存在路径/var/lib/elasticsearch/nodes/0/indices,可以修改elasticsearch.yml配置文件path to data,path to logs,重启服务生效镜像网卡开启混杂模式 ifconfig eth0 promiscfreeSpaceG = 5%存放PCAP文件的空间重复使用的临界空间值插入手动添加的PCAP文件 ${moloch_dir}/bin/moloch-capture -c [config_file] -r [pcap_file]无法启动molochcapture.service, ERROR - pcap open failed - Couldn't open file: '/data/moloch-nightly/raw/localhost-180207-00000038.pcap' with Permission denied (13). 原因是用户问题，chownnobody:root raw/ ,设置nobody用户就可以了path.data path.logs设置了指定路径后，无法启动elasticsearch服务，原因是指定的路径权限是root，需要修改成elasticsearch用户和组","categories":[{"name":"network","slug":"network","permalink":"https://www.browsersytle.cn/categories/network/"}],"tags":[{"name":"moloch","slug":"moloch","permalink":"https://www.browsersytle.cn/tags/moloch/"}]},{"title":"qemu制作CentOS7虚拟机镜像文件","slug":"qemu制作CentOS7虚拟机镜像文件","date":"2019-07-16T14:24:28.000Z","updated":"2019-07-16T14:25:06.797Z","comments":true,"path":"2019/07/16/qemu制作CentOS7虚拟机镜像文件.html","link":"","permalink":"https://www.browsersytle.cn/2019/07/16/qemu制作CentOS7虚拟机镜像文件.html","excerpt":"","text":"一、硬件支持1234567#Intel,有输出表示支持虚拟化cat /proc/cpuinfo | grep vmxflags : fpu vme de pse tsc msr pae mce cx8 apic sep mtrr pge mca cmov pat pse36 clflush dts mmx fxsr sse sse2 ss syscall nx rdtscp lm constant_tsc arch_perfmon pebs bts nopl xtopologytsc_reliable nonstop_tsc pni pclmulqdq vmx ssse3 cx16 pcid sse4_1 sse4_2 x2apic popcnt tsc_deadline_timer aes xsave avx f16c rdrand hypervisor lahf_lm arat tpr_shadow vnmi ept vpid fsgsbase tsc_adjustsmep#AMDcat /proc/cpuinfo | grep svm如果是vm虚拟机，记得开启cpu的虚拟化功能 二、安装kvm笔者的环境是CentOS 7.3 16111234yum install epel-releaseyum install qemu#安装完后，会发现在/usr/bin/ 目录下没有qemu-kvm文件，文件在/usr/libexec/目录下，只能做一个软连接ln -s /usr/libexec/qemu-kvm /usr/bin/qemu-kvm 三、建立虚拟磁盘在/opt目录下新建一个kvm文件夹，并且建立一个ISO文件夹，里面放入要安装的系统iso镜像123#创建一个磁盘40G大小，格式为qcow2的文件qemu-img create -f qcow2 centos7.qcow2 40G#文件格式有很多，qcow2 raw qcow cow vmdk 等 四、安装操作系统12345678910111213/usr/bin/qemu-kvm -cpu kvm64 -m 2048 -boot c \\ -drive file=/opt/kvm/centos7.qcow2,if=virtio,index=0,media=disk,format=qcow2 \\ -drive file=/opt/kvm/ISO/CentOS-7.4-x86_64-Minimal-1708.iso,index=1,media=cdrom \\ -net nic,macaddr=52:54:ac:5a:d6:a1,id=eth0,model=e1000 \\ -rtc base=localtime \\ -vnc :1 &amp;#-cpu cpu类型#-m 虚拟机使用的内存#-boot c c是硬盘启动，d光驱启动#-cdrom 使用光盘镜像文件#-net 指定网卡mac和vlan（默认vlan0）#-rtc 使用本地时间同步虚拟机时间#-vnc 开启一个展示vnc服务接口运行命令后，kvm会启动进行操作系统安装，并且可以通过ss -tln看到启动了一个vnc的端口5900+下载vnc客户端软件，通过vnc客户端软件进行操作系统安装 五、注意点想要强制指定虚拟网卡的名称eth0，安装完系统重启后进行一下配置更改ifcfg-ens192文件名1mv ifcfg-ens192 ifcfg-eth0修改ifcfg-ens192配置文件1234vim ifcfg-ens192DEVICE=eth0NAME=eth0ONBOOT=yes编辑grub文件123vim /etc/default/grub#在rhgb quiet 后面添加 net.ifnames=0 biosdevname=0GRUB_CMDLINE_LINUX=\"crashkernel=auto rd.lvm.lv=cl/root rd.lvm.lv=cl/swap rhgb quiet net.ifnames=0 biosdevname=0\"重新建立grub文件并reboot12grub2-mkconfig -o /boot/grub2/grub.cfgreboot启动虚拟机123/usr/bin/qemu-kvm -cpu kvm64 -m 2048 -boot c \\ -drive file=/opt/image/centos7.qcow2 \\ -vnc :1 &amp;","categories":[{"name":"linux","slug":"linux","permalink":"https://www.browsersytle.cn/categories/linux/"}],"tags":[{"name":"qemu","slug":"qemu","permalink":"https://www.browsersytle.cn/tags/qemu/"}]},{"title":"openvpn2.7+easy3.0+tun","slug":"openvpn2-7-easy3-0-tun","date":"2019-07-16T14:01:49.000Z","updated":"2019-07-16T15:02:09.284Z","comments":true,"path":"2019/07/16/openvpn2-7-easy3-0-tun.html","link":"","permalink":"https://www.browsersytle.cn/2019/07/16/openvpn2-7-easy3-0-tun.html","excerpt":"","text":"根据业务需求提出总公司与多个分公司需要内网互访，在外人员要访问总公司网络且也要访问分公司部分内网，并且分公司和分公司之间也要能网络互访 解决方案：总部作为Server端，连接所有分公司和外部员工分公司通过旁路模式或网关模式连接到Server端，并且添加分公司路由在外人员直接通过拨vpn，进行访问 一、Server端安装配置 关闭selinux12setenforce 0sed -i '/^SELINUX=/c\\SELINUX=disabled' /etc/selinux/config 安装openvpn和必要组件easy-rsa是一个用于构建和管理PKI CA的CLI实用程序。用外行的话来说，这意味着创建一个根证书颁发机构，并请求和签署证书，包括子CA和证书撤销列表1yum install -y epel-release openvpn easy-rsa expect zip 拷贝文件123cp /usr/share/doc/openvpn-2.4.5/sample/sample-config-files/server.conf /etc/openvpn/servercp -r /usr/share/easy-rsa /etc/openvpncp -r /usr/share/doc/easy-rsa-3.0.3/vars.example /etc/openvpn/easy-rsa/3.0/vars 配置文件修改server.configvim /etc/openvpn/server/server.conf12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#监听端口port 1194#监听协议proto udp#路由模式dev tun#根证书ca /etc/openvpn/server/ca.crt#服务器证书cert /etc/openvpn/server/openvpnserver.crt#服务器秘钥key /etc/openvpn/server/openvpnserver.key#密钥交换协议文件dh /etc/openvpn/server/dh.pem# 证书注销验证crl-verify /etc/openvpn/easy-rsa/3.0/pki/crl.pem#dhcp地址池server 172.28.16.0 255.255.240.0#记录登录过的地址ifconfig-pool-persist ipp.txt#推送的路由push \"route 192.168.80.0 255.255.255.0\"push \"route 192.168.1.0 255.255.255.0\"#########添加LAN路由##############client-config-dir /etc/openvpn/ccd#客户端所在子网网段route 192.168.1.0/24###################################启用管理服务器端口，用作在线kill客户端用户,端口自定义management localhost 1194;push \"redirect-gateway def1 bypass-dhcp\"#推送DNSpush \"dhcp-option DNS 114.114.114.114\"push \"dhcp-option DNS 223.5.5.5\"#客户端访问客户端client-to-client#120秒内无法ping通，则认为丢失重新vpn，重新连接keepalive 10 120tls-auth /etc/openvpn/server/ta.key 0 cipher AES-256-CBC#数据压缩comp-lzo#最大连接数max-clients 10000user nobodygroup nobody#通过keepalive检测超时后，重新启动vpn，不重新读取keys,保留第一次使用的keyspersist-key#通过keepalive检测超时后,重新启动vpn,一直保持tun或tap设备是linkup的，否则网络连接会先linkdown然后linkuppersist-tun#把openvpn的状态写入日志中status /var/log/openvpn/openvpn-status.log 3#配合status，记录客户端字段：虚拟地址，用户名，真实地址status-version 1#日志log /var/log/openvpn/openvpn.log#日志内容追加log-append /var/log/openvpn/openvpn.log#日志记录级别verb 3#最多20条相同消息类别的连续消息将输出到日志中mute 20#当服务器重新启动时通知客户端，使其能够自动重新连接explicit-exit-notify 1修改varsvim /etc/openvpn/easy-rsa/3/vars1234567891011121314151617181920set_var EASYRSA \"$PWD\"set_var EASYRSA_PKI \"$EASYRSA/pki\"set_var EASYRSA_DN \"cn_only\"set_var EASYRSA_REQ_COUNTRY \"CN\"set_var EASYRSA_REQ_PROVINCE \"JIANGSU\"set_var EASYRSA_REQ_CITY \"SUZHOU\"set_var EASYRSA_REQ_ORG \"OpenVPN CERTIFICATE AUTHORITY\"set_var EASYRSA_REQ_EMAIL \"openvpn@test.com.cn\"set_var EASYRSA_REQ_OU \"test\"set_var EASYRSA_KEY_SIZE 2048set_var EASYRSA_ALGO rsaset_var EASYRSA_CA_EXPIRE 7000set_var EASYRSA_CERT_EXPIRE 3650# 证书注销验证的时间，默认是180天set_var EASYRSA_CRL_DAYS 3650set_var EASYRSA_NS_SUPPORT \"no\"set_var EASYRSA_NS_COMMENT \"Easy-RSA Generated Certificate\"set_var EASYRSA_EXT_DIR \"$EASYRSA/x509-types\"set_var EASYRSA_SSL_CONF \"$EASYRSA/openssl-1.0.cnf\"set_var EASYRSA_DIGEST \"sha256\" 创建证书服务端证书123456789101112131415161718cd /etc/openvpn/easy-rsa/3.0./easyrsa init-pki#创建ca，输入密码(两次)./easyrsa build-ca nopass#生成 Diffie Hellman 参数./easyrsa gen-dhopenvpn --genkey --secret ta.keycp -r ta.key /etc/openvpn/#创建服务端证书,生成请求,使用gen-req来生成req./easyrsa gen-req openvpnserver#签发证书，输入ca密码./easyrsa sign-req server openvpnserver#将服务端证书拷贝到指定目录(对应上面配置的证书路径)mv ca.crt /etc/openvpn/servermv issued/openvpnserver.crt /etc/openvpn/servermv private/openvpnserver.key /etc/openvpn/servermv dh.pem /etc/openvpn/servermv ta.key /etc/openvpn/server 网络配置开启内核转发功能12echo \"net.ipv4.ip_forward = 1\" &gt; /etc/sysctl.confsysctl -p配置iptables12345678910111213141516171819#停用firewalld，安装iptablessystemctl stop firewalldsystemctl disable firewalldyum install iptables iptables-servicessystemctl start iptablessystemctl enable iptables#查看iptables规则和序号iptables -nvL --line-number#放通1194的tcp和udp端口iptables -I INPUT 5 -p tcp -m state --state NEW -m tcp --dport 1194 -j ACCEPTiptables -I INPUT 6 -p udp -m state --state NEW -m udp --dport 1194 -j ACCEPTiptables -I FORWARD 1 -m state --state RELATED,ESTABLISHED -j ACCEPTiptables -I FORWARD 2 -s 172.28.16.0/20 -d 192.168.0.0/16 -j ACCEPT#配置nat转发iptables -t nat -A POSTROUTING -o eth0 -j MASQUERADE#保存iptables配置service iptables save#重新加载iptables配置文件service iptables restart 配置证书注销验证客户端使用证书登入，在注销时，可以使用easy-rsa revoke $vpnuser进行注销证书，并在index.txt下进行日志记录，但是在实践过程中发现，仅仅在服务端注销证书后，客户端仍然可以登入，原因是openvpn没有调用注销客户端信息的资料，需要在server.conf配置文件中引用crl.pem注销文件。V为可用，R为注销创建crl.pem更新文件12/etc/openvpn/easy-rsa/3/easyrsa gen-crlchmod 666 /etc/openvpn/easy-rsa/3/pki/crl.pem配置server.conf1echo \"crl-verify /etc/openvpn/easy-rsa/3.0/pki/crl.pem\" &gt;&gt; /etc/openvpn/server.conf注意：在vars文件中的set_var EASYRSA_CRL_DAYS默认是注释的，并且默认天数是180天，所以创建的crl.pem超过180天后，客户端连接服务端会失败报错WARNING: Failed to stat CRL file, not (re)loading CRL。所以修改vars文件的EASY_CRL_DAYS的天数，建议改成3650，十年够用了。然后重新生成crl.pem证书，重启openvpn服务，搞定。 在线查看客户端连接以及关闭客户端连接在线查看客户端连接信息要想查看客户端连接信息，需要在server.conf配置文件中添加日志记录配置(配置文件已经包含在上面server.conf文件中)1234#把openvpn的状态写入日志中status /var/log/openvpn/openvpn-status.log 3#配合status，记录客户端字段：虚拟地址，用户名，真实地址，版本选择可以是1、2、3status-version 1查看日志： tail -f /var/log/openvpn/openvpn-status.log在线关闭客户端连接openvpn支持在线断开client用户，前提在server.conf配置中添加management localhost port12345678910#!/bin/bash##Date: 2018-10-23##Author: Browser##Description: turnoff the online users##Version: 1.0vpnuser=$1(sleep 1echo kill $vpnusersleep 1) | telnet localhost 1194关闭在线用户：bash openvpn_close_client.sh vpnuser 启动Server端openvpn服务1234#由于ca证书无密码，所以直接启动systemctl start openvpn@server#设置开机启动systemctl enable openvpn@server 客户端证书文件客户端需要的证书：client.crt、client.key、ca.crt、ta.key、client.ovpn客户端配置文件vim client.ovpn1234567891011121314151617181920clientdev tunproto udpresolv-retry infinitenobindremote xxxxxx 1194#将证书指定为服务器remote-cert-tls servercomp-lzokeepalive 10 120persist-keypersist-tunverb 5cipher AES-256-CBC#redirect-gatewayroute-method exeroute-delay 2status client-status.log#log-append client.logkey-direction 1为了方便自动化创建、删除vpn账号，需要将默认client.ovpn、ca.key、ta.key放到一个指定的文件夹下mkdir -p /etc/openvpn/easy-rsa/3/pki/Epoint，将三个文件拷贝到此文件夹下 自动化创建管理秘钥自动化创建秘钥需要账号密码交互，需要用到expect工具安装expect1yum install expect -y创建vpnuser脚本脚本中在创建用户证书时没有配置密码，直接nopass，也可以配置密码，这样客户端登入时则需要通过密码登入vim /etc/openvpn/easy-rsa/3/openvpn_user_create.expect123456789101112131415161718192021#!/usr/bin/expect -f##Date: 2018-05-09##Author: Browser##Description: create the vpnuser certificate##Version: 1.0if $argc&lt;1 &#123; puts stderr \"Usage: $argv0 need argv.\\n\" exit 1 &#125; set vpnuser [lindex $argv 0] set path /etc/openvpn/easy-rsa/3.0spawn $path/easyrsa build-client-full $vpnuser expect \"Enter PEM pass phrase:\" send \"$vpnuser@vpn\\r\" expect \"Verifying - Enter PEM pass phrase:\" send \"$vpnuser@vpn\\r\"# expect \"Enter pass phrase for /etc/openvpn/easy-rsa/3.0/pki/private/ca.key:\"#输入ca证书配置的密码# send \"password\\r\" expect eof exit删除vpnuser脚本vim /etc/openvpn/easy-rsa/3/openvpn_user_delete.expect1234567891011121314151617181920212223#!/usr/bin/expect -f##Date: 2018-05-09##Author: Browser##Description: Delete the vpnuser certification##Version: 1.0if $argc&lt;1 &#123; puts stderr \"Usage: $argv0 need argv.\\n\" exit 1 &#125; set vpnuser [lindex $argv 0] set path /etc/openvpn/easy-rsa/3.0 spawn $path/easyrsa revoke $vpnuser expect \"Continue with revocation:\" send \"yes\\r\"# expect \"Enter pass phrase for /etc/openvpn/easy-rsa/3.0/pki/private/ca.key:\"# send \"epoint\\r\" expect eofspawn $path/easyrsa gen-crl expect eofchmod 666 /etc/openvpn/easy-rsa/3/pki/crl.pem exit12chmod 755 openvpn_user_create.expectchmod 755 openvpn_user_delete.expect上述两个脚本是用来创建vpn账号的证书和私钥通过下面这个脚本，可以直接将vpn账号的私钥、证书、ca、ta.key、dh.epm和client.opvn结合到一起，直接打包输出到指定文件夹下，方便提取和删除创建vpnuser命令脚本vim /usr/local/bin/vpnuser1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798#!/bin/bash##Date: 2018-08-30##Author: Browser_xyj##Description: add or del vpnuser##Version: 1.2num=$#choose=$1vpn_user=$2DIR=/etc/openvpn/easy-rsa/3.0/pkiCLIENT=/etc/openvpn/client openvpn_help() #帮助函数 &#123; echo '添加vpn用户执行命令: vpnuser add vpn用户名' echo '删除vpn用户执行命令: vpnuser del vpn用户名' &#125; add_user() #新建vpn用户函数&#123;if [ -f $DIR/issued/$vpn_user.crt ];then echo \"==================&lt;温馨提示&gt;==================\" echo \"VPN用户：$vpn_user已存在,请检查后操作!!\" echo \"==============================================\"else cd /etc/openvpn/easy-rsa/3.0 #创建用户 ./openvpn_user_create.expect $vpn_user &amp;&gt;/dev/null #创建client文件夹 mkdir -p $CLIENT/$vpn_user cp $DIR/Epoint/client.ovpn $CLIENT/$vpn_user/$vpn_user.ovpn #echo ca、key、crt echo \"&lt;ca&gt;\" &gt;&gt; $CLIENT/$vpn_user/$vpn_user.ovpn cat $DIR/Epoint/ca.crt &gt;&gt; $CLIENT/$vpn_user/$vpn_user.ovpn echo \"&lt;/ca&gt;\" &gt;&gt; $CLIENT/$vpn_user/$vpn_user.ovpn echo \"&lt;tls-auth&gt;\" &gt;&gt; $CLIENT/$vpn_user/$vpn_user.ovpn cat $DIR/Epoint/ta.key &gt;&gt; $CLIENT/$vpn_user/$vpn_user.ovpn echo \"&lt;/tls-auth&gt;\" &gt;&gt; $CLIENT/$vpn_user/$vpn_user.ovpn echo \"&lt;cert&gt;\" &gt;&gt;$CLIENT/$vpn_user/$vpn_user.ovpn cat $DIR/issued/$vpn_user.crt &gt;&gt; $CLIENT/$vpn_user/$vpn_user.ovpn echo \"&lt;/cert&gt;\" &gt;&gt;$CLIENT/$vpn_user/$vpn_user.ovpn echo \"&lt;key&gt;\" &gt;&gt;$CLIENT/$vpn_user/$vpn_user.ovpn cat $DIR/private/$vpn_user.key &gt;&gt; $CLIENT/$vpn_user/$vpn_user.ovpn echo \"&lt;/key&gt;\" &gt;&gt;$CLIENT/$vpn_user/$vpn_user.ovpn #client打包 cd $CLIENT zip -r $vpn_user.zip $vpn_user &amp;&gt;/dev/null mv $vpn_user.zip /opt/vpnuser/ echo \"=========================&lt;成功提示&gt;============================\" echo \"VPN用户:$vpn_user创建成功!\" echo \"=========================&lt;成功提示&gt;============================\" echo \"vpn用户:$vpn_user 密钥已生成在/opt/vpnuser 下，请自行获取！！！\" echo \"===============================================================\" fi&#125; del_user() #删除vpn用户函数&#123; cd /etc/openvpn/easy-rsa/3.0/ ./openvpn_user_delete.expect $vpn_user &amp;&gt;/dev/null rm -rf $DIR/issued/$vpn_user.crt rm -rf $DIR/private/$vpn_user.key rm -rf $DIR/reqs/$vpn_user.req rm -rf $CLIENT/$vpn_user rm -rf /opt/vpnuser/$vpn_user.zip echo \"=========================&lt;成功提示&gt;============================\" echo \"注销并已删除vpn用户:$vpn_user成功!\" echo \"===============================================================\"&#125; main_vpn() #主函数&#123;if [ $num -ne 2 ];then echo \"=======================&lt;错误提示&gt;========================\" echo \"输入参数无效,请检查!\" echo \"=======================&lt;帮助提示&gt;========================\" openvpn_help echo \"=========================================================\" else if [ $choose = \"add\" ];then add_user elif [ $choose = \"del\" ];then del_user else echo \"=======================&lt;错误提示&gt;========================\" echo '输入参数类型无效,类型只包含add|del' echo \"=======================&lt;帮助提示&gt;========================\" openvpn_help echo \"=========================================================\" fifi&#125;####main######main_vpn添加权限chmod 755 vpnuser检测变量PATHecho $PATH/usr/local/sbin:/usr/local/bin:/sbin:/bin:/usr/sbin:/usr/bin:/root/bin 账号创建测试创建用户1vpnuser add test删除用户1vpnuser del test 二、Client端安装配置 windows客户端openvpn-2.4.6客户端下载下载windows客户端软件，将压缩文件夹放入config文件夹，解压缩就可以，双机运行openvpn，右下角右击选择指定vpn进行连接（config文件夹下可以放置多个账号文件） Linux客户端1yum install openvpn zip unzip将账号压缩包文件传到/etc/openvpn/client目录下解压启动脚本vim /root/openvpn_start.sh1234567891011#!/bin/bashvpnuser=$1if [[ $# -le 0 ]];then echo -e \"\\e[1;31m =======Please input vpnuser======= \\e[0m\" exit 1fiopenvpn --daemon --cd /etc/openvpn/client/$1 --config $1.ovpn --log-append /var/log/openvpn.log# --daemon ：openvpn以daemon方式启动# --cd dir : 配置文件的目录，openvpn初始化前，先前切换到此目录# --config file ：客户端配置文件的路径# --log-append file ：日志文件路径，如果文件不存在会自动创建有多个账号的情况下，可以通过此脚本自行选择连接sh openvpn_start.sh $vpnuser关闭脚本vim /root/openvpn_stop.sh12#!/bin/bashps axu | grep \"openvpn\" | grep -v grep | awk '&#123; print $2 &#125;' | xargs kill -9sh openvpn_stop.sh MacOS客户端Tunnelblick下载地址Tunnelblick官网Mac版本使用 很方便，安装好后，直接双机ovpn证书文件，提示输入Mac账号密码，然后就直接注入到tunnelblick软件中，选择指定证书进行vpn连接。 iPhone客户端17年左右还是能从appstore中下载openvpn的app，但是之后就被下架，如果想要使用openvpn的app，则需要通过国外账号登入appstore中下载美版的openvpn。在openvpn服务端创建证书，将证书ovpn通过邮件发给自己，并且在手机端邮箱中下载证书文件，并选择手机端openvpn程序打开，这样就能把证书文件导入到openvpn app中，配置密码保存即可，然后就能正常连接。连接有错误，可以查看右上角的日志信息，目前app端不支持dev tap 模式 三、客户端Lan访问配置以下是示例，根据示例进行配置分公司有一个openvpn服务器，后面有一个lan（10.10.2.0/24），后面有两个带有lans的客户端：cleint1与lan 10.10.1.0/24client2与lan 10.10.3.0/24希望所有3个lans上的机器能够使用tun（路由）设置进行通信。其后面有LAN的每台计算机都必须启用IP转发。在此示例中，表示服务器和client1 / client2。用户在他的server.conf中需要以下内容：123456route 10.10.1.0 255.255.255.0route 10.10.3.0 255.255.255.0push \"route 10.10.2.0 255.255.255.0\"push \"route 10.10.1.0 255.255.255.0\"push \"route 10.10.3.0 255.255.255.0\"client-to-clientiroute条目告诉openvpn服务器哪个客户端负责网络。12345#中心服务端创建ccd目录mkdir -p /etc/openvpn/ccdcd /etc/openvpn/ccd#vpnuser账号名要对应好，因为系统是根据账号名进行识别echo \"iroute 10.10.2.0 255.255.255.0\" &gt; $vpnuser上面为了让客户端的lan与lan进行路由转发，进行了openvpn Server端的配置，配置完成后，仅仅只能访问到client本机地址，还无法访问相关lan网段其他主机，需要在此client端配置路由转发才能访问123456789101112#开启路由转发echo \"net.ipv4.ip_forward = 1\" &gt; /etc/sysctl.conf sysctl -p#配置nat转发iptables -t nat -A POSTROUTING -o eno16780032 -s 172.28.16.0/20 -j MASQUERADE配置forward路由转发iptables -I FORWARD 1 -m state --state RELATED,ESTABLISHED -j ACCEPTiptables -I FORWARD 2 -s 172.28.16.0/28 -d 192.168.208.0/24 -i tun0 -o eth0 -m conntrack --ctstate NEW -j ACCEPT#清空iptables规则#iptables -F#保存serice iptables save","categories":[{"name":"network","slug":"network","permalink":"https://www.browsersytle.cn/categories/network/"}],"tags":[{"name":"openvpn","slug":"openvpn","permalink":"https://www.browsersytle.cn/tags/openvpn/"}]},{"title":"Nginx限制并发连接数和带宽","slug":"Nginx限制并发连接数和带宽","date":"2019-06-19T14:41:16.000Z","updated":"2019-06-19T15:08:03.320Z","comments":true,"path":"2019/06/19/Nginx限制并发连接数和带宽.html","link":"","permalink":"https://www.browsersytle.cn/2019/06/19/Nginx限制并发连接数和带宽.html","excerpt":"","text":"一、TCP连接对于一些服务器流量异常、负载过大，甚至是大流量的恶意攻击访问等，进行并发数的限制（共享内存和并发限制需结合系统定制）limit_conn_zone 设置共享内存区域参数123Syntax: limit_conn_zone key zone=name:size;Default: —Context: httplimit_conn 设置共享内存区域和给定键值的最大允许连接数123Syntax: limit_conn zone number;Default: —Context: http, server, locationlimit_conn_log_level 日志可以调整级别，默认error12345Syntax: limit_conn_log_level info | notice | warn | error;Default: limit_conn_log_level error;Context: http, server, location#This directive appeared in version 0.8.18.limit_conn_status 返回状态码响应拒绝请求，默认50312345Syntax: limit_conn_status code;Default: limit_conn_status 503;Context: http, server, location#This directive appeared in version 1.3.15.示例12345678910http &#123;limit_conn_zone $binary_remote_addr zone=perip:10m;limit_conn_zone $server_name zone=perserver_tcp:10m;server &#123; location /download/ &#123; limit_conn perserver_tcp 100;#虚拟服务同时只允许100个连接 limit_conn perip 10;#每个IP同时只允许10个连接 &#125; &#125;&#125;如果共享内存空间10m被耗尽，服务器将会对后续所有的请求返回503 (Service Temporarily Unavailable)错误将限制每个客户机IP到服务器的连接数量，同时限制到虚拟服务器的连接总数: 二、HTTP连接限制来自单个IP地址的请求处理频率，每秒固定处理请求数，推迟过多请求。以此来防止应用层的DDOS攻击（共享内存和请求频率需结合系统定制）limit_req_zone 设置共享内存区域参数123Syntax: limit_req_zone key zone=name:size rate=rate;Default: —Context: httplimit_req 设置共享内存区域、突发大小、延时123Syntax: limit_req zone=name [burst=number] [nodelay];Default: —Context: http, server, locationlimit_req_log_level 日志可以调整级别，默认error12345Syntax: limit_req_log_level info | notice | warn | error;Default: limit_req_log_level error;Context: http, server, location#This directive appeared in version 0.8.18.limit_req_status 返回状态码响应拒绝请求，默认50312345Syntax: limit_req_status code;Default: limit_req_status 503;Context: http, server, location#This directive appeared in version 1.3.15.示例1234567891011http &#123;limit_req_zone $binary_remote_addr zone=ten:20m rate=100r/s;limit_req_zone $server_name zone=perserver_http:20m rate=1000r/s;server &#123; location /search/ &#123; limit_req zone=ten burst=500 nodelay; #每秒100个请求，突发不超过500个请求，降低延时请求 limit_req zone=perserver_http burst=1500; #虚拟服务同时每秒1000个请求，突发不超过1500 &#125; &#125;&#125;如果不希望在请求受到限制时延迟过多的请求，加入参数nodelay当且仅当当前级别上没有limit_req指令时，这些指令才从上一级别继承同时可以有几个limit_req指令 三、带宽限制limit_rate限制对客户机的响应传输速率1234Syntax: limit_rate rate;Default: limit_rate 0;Context: http, server, location, if in location限制对客户机的响应传输速率。速率以字节/秒为单位指定。零值禁止速率限制。此限制是针对每个请求设置的，因此如果客户端同时打开两个连接，总体速率将是指定限制的两倍。示例123456server &#123; if ($slow) &#123; set $limit_rate 4k; &#125; ...&#125;速率限制也可以在$limit_rate变量中设置limit_rate_after设置初始值，在此之后，对客户机响应的进一步传输将受到速率限制。12345Syntax: limit_rate_after size;Default: limit_rate_after 0;Context: http, server, location, if in locationThis directive appeared in version 0.8.0.示例12345location /flv/ &#123; flv; limit_rate_after 500k; limit_rate 50k;&#125; 四、参考值Nginx服务器上查看ESTABLISHED的连接数，根据这个连接数来限制tcp连接，上浮10%1Shell&gt;netstat -n | awk '/^tcp/ &#123;++S[$NF]&#125; END &#123;for(a in S) print a, S[a]&#125;'Web浏览器查看nginx服务器的epoint_base_status查看Req/s，根据这个值进行请求数的限制，上浮10%","categories":[{"name":"Nginx","slug":"Nginx","permalink":"https://www.browsersytle.cn/categories/Nginx/"}],"tags":[{"name":"limit","slug":"limit","permalink":"https://www.browsersytle.cn/tags/limit/"}]},{"title":"FLASK","slug":"Flask","date":"2019-05-20T13:58:47.000Z","updated":"2019-07-18T05:42:19.685Z","comments":true,"path":"2019/05/20/Flask.html","link":"","permalink":"https://www.browsersytle.cn/2019/05/20/Flask.html","excerpt":"","text":"安装flask123456789101112131415# 安装pipyum install python-pip# 安装pipenvpip install pipenv# 创建虚拟环境mkdir helloflask &amp;&amp; cd helloflaskpipenv install# 激活虚拟环境,从当前目录的.env读取环境变量pipenv shell/run# 查看当前环境依赖情况pipenv graph# 安装flaskpipenv install flask# 更新flaskpipenv update flaskPipfile: 记录项目依赖包列表Pipfile.lock: 记录了固定版本的详细依赖包列表 环境变量环境变量优先级： 手动设置》.evn设置》.flaskenv设置手动设置环境变量1234# linuxexport FLASK_APP=hello# windowsset FLASK_APP=hello安装python-dotenv12345pipenv isntall python-dotenv# 创建.env，存储包含敏感信息的环境变量touch .env# 创建 .flaskenv，存储flask相关的公开环境变量touch .flaskenv环境变量中是以键值对的形式的定义每行一个#开头为注释设置.flaskenv1234# 设置开发环境FLASK_ENV=development# 设置appFLASK_APP=hello","categories":[{"name":"python","slug":"python","permalink":"https://www.browsersytle.cn/categories/python/"}],"tags":[{"name":"flask","slug":"flask","permalink":"https://www.browsersytle.cn/tags/flask/"}]}]}